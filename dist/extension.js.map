{"version":3,"sources":[".././src/extension.js","../external \"fs\"","../external \"vscode\"","../webpack/bootstrap","../webpack/startup"],"names":[],"mappings":";;;;;;;;;AAAA,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,eAAe,mBAAO,CAAC,cAAI;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,iDAAiD;AACjD,6CAA6C;AAC7C,6BAA6B;AAC7B,IAAI;AACJ;AACA;AACA;AACA,kCAAkC,MAAM,MAAM,UAAU;AACxD,kCAAkC,KAAK,EAAE,MAAM,UAAU;AACzD,6FAA6F,kBAAkB;AAC/G,KAAK;AACL;AACA;;AAEA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,MAAM;AAClF,wEAAwE,MAAM;AAC9E,kFAAkF,MAAM;AACxF,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,EAAE;;;AAGF,6JAA6J,oBAAoB;AACjL;AACA;AACA;AACA;;AAEA;AACA;AACA,gDAAgD,UAAU;AAC1D,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACtHA,gC;;;;;;;;;;;ACAA,oC;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;UCtBA;UACA;UACA;UACA","file":"extension.js","sourcesContent":["const vscode = require('vscode');\nconst fs     = require('fs');\n\nconst main = (fsPath) => {\n\tconst svgFiles   = [];\n\tconst symbolList = [];\n\tconst SAPARATOR  = '__';\n\tconst curDir     = fsPath.replace(/\\\\/g, '/');\n\tconst filesInDir = fs.readdirSync(curDir);\n\tconst FILE_NAME  = vscode.workspace.getConfiguration('svgSpriteGenerator')['outputFileName'].replace(/[^-_.A-Za-z0-9]/g, '');\n\n\t// если фалы лежат в 'node_modules' - не обрабатываем и выходим\n\tif (fsPath.indexOf('node_modules') > -1) return;\n\n\tfilesInDir.forEach(file => {\n\t\tif ( file.endsWith('.svg') )\n\t\tsvgFiles.push( curDir + '/' + file);\n\t});\n\n\tif ( ! svgFiles.length ) {\n\t\tvscode.window.showInformationMessage('SVG files not found!');\n\t\treturn false;\n\t}\n\n\tsvgFiles.forEach((path, idx) => {\n\t\tlet fileName  = path.replace(/.+[\\\\/](.*)\\.svg/gi, '$1').replace(/\\s/gi, '-');\n\t\tlet svgString = fs.readFileSync(path).toString();\n\t\tlet svgHTML   = svgString.match(/<svg.+<\\/svg>/gis) ? svgString.match(/<svg.+<\\/svg>/gis)[0] : '';\n\t\tlet style     = svgString.match(/<style[^>].+<\\/style>/gis) ? svgString.match(/<style[^>].+<\\/style>/gis)[0] : '';\n\t\tlet viewBox   = svgString.replace(/.*viewBox\\s?=[\"]([^\"]+)[\"].*/gis, '$1');\n\t\tlet symbol    = '';\n\n\t\tif ( !svgHTML.length || !viewBox.length ) return false;\n\n\t\t// если в текущем файле есть symbol - значит это уже спрайт и мы его пропускаем\n\t\tif ( svgString.toLowerCase().indexOf(\"symbol\".toLowerCase()) > -1 ) return false;\n\n\t\t// обрабатываем все css-классы данного SVG\n\t\tif ( style.length && style.match(/([.\\w]+)(\\s*{)/isg).length ) {\n\t\t\tlet classList = style.match(/([.\\w]+)(\\s*{)/isg).map(item => {\n\t\t\t\treturn item.replace(/\\s*{/gi, '');\n\t\t\t});\n\t\t\tif ( classList.length ) {\n\t\t\t\tclassList.forEach(item => {\n\t\t\t\t\tlet newClass = item + SAPARATOR + idx;\n\t\t\t\t\tsvgHTML = svgHTML.replace(`${item}{`, `${newClass}{`);\n\t\t\t\t\tsvgHTML = svgHTML.replace(`${item} {`, `${newClass}{`);\n\t\t\t\t\tsvgHTML = svgHTML.replace(new RegExp('class=\"' + item.slice(1) + '\"', 'gis'), `class=\"${newClass.slice(1)}\"`);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// обрабатываем все css-ID данного SVG\n\t\t// например тут: <rect id=\"SVGID_1_\" x=\"3.5\" y=\"1\" width=\"17\" height=\"22\"></rect>\n\t\t// и тут: <use xlink:href=\"#SVGID_1_\" style=\"overflow:visible;\"></use>\n\t\t// и тут: <path d=\"M2000 0H-3V503H2000V0Z\" fill=\"url(#paint0_linear)\"/>\n\t\tif ( !! svgHTML.match(/\\bid=\"[^\"]+\"/isg) ) {\n\t\t\tlet idList = svgHTML.match(/\\bid=\"[^\"]+\"/isg).map(item =>\n\t\t\t\titem.replace(/id=\"|\"/gi, '')\n\t\t\t);\n\t\t\tif ( idList.length ) {\n\t\t\t\tidList.forEach(item => {\n\t\t\t\t\tlet newID = item + SAPARATOR + idx;\n\t\t\t\t\tsvgHTML = svgHTML.replace(new RegExp('id=\"' + item + '\"', 'g'), `id=\"${newID}\"`);\n\t\t\t\t\tsvgHTML = svgHTML.replace(new RegExp('\"#' + item + '\"', 'g'), `\"#${newID}\"`)\n\t\t\t\t\tsvgHTML = svgHTML.replace(new RegExp('url[(]#' + item + '[)]', 'g'), `url(#${newID})`);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tlet symbolInnerHtml = svgHTML.replace(/.*<svg[^>]+>(.+)<\\/svg>/gsi, '$1');\n\n\t\t// убрать разрывы строки внутри path\n\t\tsymbolInnerHtml = symbolInnerHtml.replace(/[\\r\\n]+\\s*(\\w)/g, '$1');\n\t\tsymbolInnerHtml = symbolInnerHtml.replace(/[\\r\\n]+\\s*\"/g, ' \"');\n\t\tsymbolInnerHtml = symbolInnerHtml.replace(/\"[\\r\\n]+\\s*\\/>/g, '\"/>');\n\n\t\t// подогнать все теги к левому краю\n\t\tsymbolInnerHtml = symbolInnerHtml.replace(/[\\r\\n]+\\s*</gs, '\\n<');\n\n\t\t// формируем symbol\n\t\tsymbol = '<symbol id=\"' + fileName + '\" viewBox=\"' + viewBox + '\" xmlns=\"http://www.w3.org/2000/svg\">'\n\t\t\t\t+ symbolInnerHtml\n\t\t\t\t+ '</symbol>';\n\n\t\tsymbolList.push(symbol);\n\t});\n\n\n\tlet sprite = '<svg width=\"0\" height=\"0\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" style=\"visibility: hidden; position: absolute;\" aria-hidden=\"true\">'\n\t\t\t\t+ '\\n\\n'\n\t\t\t\t+ symbolList.join(\"\\n\\n\")\n\t\t\t\t+ '\\n\\n'\n\t\t\t\t+ '</svg>';\n\n\tfs.writeFile(curDir + '/' + FILE_NAME + '.svg', sprite, function (err) {\n\t\tif (err) throw err;\n\t\tvscode.window.showInformationMessage(`File \"${FILE_NAME}.svg\" saved to the current folder`);\n\t});\n}\n\n// this method is called when your extension is activated\n// your extension is activated the very first time the command is executed\nfunction activate(context) {\n\tconst disposable = vscode.commands.registerCommand('smat.svgSpriteGenerate', (e) => {\n\t\tmain(e.fsPath);\n\t});\n\n\tcontext.subscriptions.push(disposable);\n}\n\n// this method is called when your extension is deactivated\n// vscode.commands.executeCommand('copyFilePath')\nfunction deactivate() {}\n\nmodule.exports = {\n\tactivate,\n\tdeactivate\n}\n","module.exports = require(\"fs\");;","module.exports = require(\"vscode\");;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/extension.js\");\n"],"sourceRoot":""}